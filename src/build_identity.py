#!/usr/bin/env python3
"""
Dynamic Identity Library Builder
Reads identity_config.json, generates identity.c with values, and compiles it
"""

import json
import sys
import os
import subprocess
from datetime import datetime

CONFIG_FILE = "../config/identity_config.json"
OUTPUT_C_FILE = "../identity.c"
OUTPUT_SO_FILE = "../identity.so"

C_TEMPLATE = """// Auto-generated by build_identity.py on {timestamp}
// Profile: {profile}
// DO NOT EDIT MANUALLY - Modify identity_config.json instead

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdarg.h>
#include <time.h>
#include <sys/time.h>
#include <sys/sysinfo.h>
#include <ifaddrs.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

// =========================================================================
// CONFIGURATION - AUTO-GENERATED FROM {config_file}
// =========================================================================

struct mapping {{
    const char* real_path;
    const char* fake_data;
}};

struct net_spoof {{
    const char* interface_name;
    const char* fake_mac;
}};

static time_t time_offset = 0;
static int timing_variance = 0;
static int gpu_spoofing_disabled = 0;
static int safe_mode = 0;

// Generated identity data
static const char* FAKE_HOSTNAME = "{hostname}";

static struct mapping mappings[] = {{
    // Core System Identifiers
    {{ "/etc/machine-id",                  "{machine_id}{suffix}\\n" }},
    {{ "/var/lib/dbus/machine-id",         "{machine_id}{suffix}\\n" }},
    {{ "/sys/class/dmi/id/product_uuid",   "{product_uuid}{suffix}\\n" }},
    {{ "/sys/class/dmi/id/product_serial", "{product_serial}{suffix}\\n" }},
    {{ "/sys/class/dmi/id/board_serial",   "{board_serial}{suffix}\\n" }},
    {{ "/sys/class/dmi/id/chassis_serial", "{chassis_serial}{suffix}\\n" }},
    {{ "/sys/class/dmi/id/product_name",   "{product_name}\\n" }},
    {{ "/sys/class/dmi/id/board_name",     "{board_name}\\n" }},
    {{ "/sys/class/dmi/id/board_vendor",   "{board_vendor}\\n" }},
    {{ "/sys/class/dmi/id/bios_vendor",    "{bios_vendor}\\n" }},
    {{ "/sys/class/dmi/id/bios_version",   "{bios_version}\\n" }},
    {{ "/sys/class/dmi/id/bios_date",      "{bios_date}\\n" }},
    
    // CPU Information
    {{ "/proc/cpuinfo",
{cpuinfo_data}
    }},
    
    // Operating System
    {{ "/etc/os-release", 
        "PRETTY_NAME=\\"{os_name} {os_version}\\"\\nNAME=\\"{os_name}\\"\\nVERSION_ID=\\"{os_version_id}\\"\\n"
        "VERSION=\\"{os_version}\\"\\nID={os_id}\\nID_LIKE=debian\\n" 
    }},
    {{ "/proc/version", 
        "Linux version {kernel_release} (buildd@lcy02-amd64-053) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) {kernel_version}\\n" 
    }},
    
    // Storage Identifiers
    {{ "/sys/block/sda/device/serial",     "{sda_serial}{suffix}\\n" }},
    {{ "/sys/block/nvme0n1/device/serial", "{nvme_serial}{suffix}\\n" }},
    {{ "/sys/block/sda/device/model",      "{sda_model}\\n" }},
    {{ "/sys/block/nvme0n1/device/model",  "{nvme_model}\\n" }},
    
    // GPU Identifiers
    {{ "/sys/class/drm/card0/device/vendor",           "{nvidia_vendor}\\n" }},
    {{ "/sys/class/drm/card0/device/device",           "{nvidia_device}\\n" }},
    {{ "/sys/class/drm/card0/device/subsystem_vendor", "0x1028\\n" }},
    {{ "/sys/class/drm/card0/device/subsystem_device", "0x087d\\n" }},
    {{ "/sys/devices/pci0000:00/0000:00:02.0/vendor",           "{intel_vendor}\\n" }},
    {{ "/sys/devices/pci0000:00/0000:00:02.0/device",           "{intel_device}\\n" }},
    {{ "/sys/devices/pci0000:00/0000:00:02.0/subsystem_vendor", "0x1028\\n" }},
    {{ "/sys/devices/pci0000:00/0000:00:02.0/subsystem_device", "0x087d\\n" }},
    
    // Network MAC Addresses
{network_mappings}
    
    // Boot and Kernel Identifiers
    {{ "/proc/sys/kernel/random/boot_id",  "{boot_id}{suffix}\\n" }},
    {{ "/proc/sys/kernel/random/uuid",     "{random_uuid}{suffix}\\n" }},
    
    // Container Detection Evasion
    {{ "/proc/self/cgroup",                "0::/\\n" }},
    {{ "/sys/hypervisor/type",             "" }},
    
{battery_mappings}
    
    // Memory Information
{memory_mappings}
    
    // Display/Monitor Information  
{display_mappings}
}};

static struct net_spoof net_spoofs[] = {{
{network_spoofs}
}};

// =========================================================================
// FILE OPERATION INTERCEPTION
// =========================================================================

// Helper function to check if path is GPU-related and should be skipped
static int is_gpu_path(const char* path) {{
    if (gpu_spoofing_disabled) {{
        // Skip GPU paths for whitelisted apps
        if (strncmp(path, "/sys/class/drm/", 15) == 0 ||
            strncmp(path, "/sys/devices/pci", 16) == 0 ||
            strncmp(path, "/dev/dri/", 9) == 0) {{
            return 1;
        }}
    }}
    return 0;
}}

// Helper to bypass certain mappings in safe_mode for fragile GUI apps
static int should_bypass_path(const char* path) {{
    if (!safe_mode) {{
        return 0;
    }}
    // In safe_mode, avoid spoofing battery, backlight and meminfo
    if (strncmp(path, "/sys/class/power_supply/", 24) == 0) return 1;
    if (strncmp(path, "/sys/class/backlight/", 21) == 0) return 1;
    if (strcmp(path, "/proc/meminfo") == 0) return 1;
    return 0;
}}

static FILE* (*real_fopen)(const char*, const char*) = NULL;
FILE* fopen(const char* path, const char* mode) {{
    if (is_gpu_path(path) || should_bypass_path(path)) {{
        if (!real_fopen) {{ real_fopen = dlsym(RTLD_NEXT, "fopen"); }}
        return real_fopen(path, mode);
    }}
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {{
        if (strcmp(path, mappings[i].real_path) == 0) {{
            return fmemopen((void*)mappings[i].fake_data, strlen(mappings[i].fake_data), mode);
        }}
    }}
    if (!real_fopen) {{ real_fopen = dlsym(RTLD_NEXT, "fopen"); }}
    return real_fopen(path, mode);
}}

static FILE* (*real_fopen64)(const char*, const char*) = NULL;
FILE* fopen64(const char* path, const char* mode) {{
    if (is_gpu_path(path) || should_bypass_path(path)) {{
        if (!real_fopen64) {{ real_fopen64 = dlsym(RTLD_NEXT, "fopen64"); }}
        return real_fopen64(path, mode);
    }}
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {{
        if (strcmp(path, mappings[i].real_path) == 0) {{
            return fmemopen((void*)mappings[i].fake_data, strlen(mappings[i].fake_data), mode);
        }}
    }}
    if (!real_fopen64) {{ real_fopen64 = dlsym(RTLD_NEXT, "fopen64"); }}
    return real_fopen64(path, mode);
}}

static int (*real_open)(const char*, int, ...) = NULL;
int open(const char *pathname, int flags, ...) {{
    mode_t mode = 0;
    if (flags & O_CREAT) {{
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }}
    
    if (is_gpu_path(pathname) || should_bypass_path(pathname)) {{
        if (!real_open) {{ real_open = dlsym(RTLD_NEXT, "open"); }}
        return real_open(pathname, flags, mode);
    }}
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {{
        if (strcmp(pathname, mappings[i].real_path) == 0) {{
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) {{ 
                if (!real_open) {{ real_open = dlsym(RTLD_NEXT, "open"); }}
                return real_open(pathname, flags, mode);
            }}
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }}
    }}
    if (!real_open) {{ real_open = dlsym(RTLD_NEXT, "open"); }}
    return real_open(pathname, flags, mode);
}}

static int (*real_open64)(const char*, int, ...) = NULL;
int open64(const char *pathname, int flags, ...) {{
    mode_t mode = 0;
    if (flags & O_CREAT) {{
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }}
    
    if (is_gpu_path(pathname) || should_bypass_path(pathname)) {{
        if (!real_open64) {{ real_open64 = dlsym(RTLD_NEXT, "open64"); }}
        return real_open64(pathname, flags, mode);
    }}
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {{
        if (strcmp(pathname, mappings[i].real_path) == 0) {{
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) {{ 
                if (!real_open64) {{ real_open64 = dlsym(RTLD_NEXT, "open64"); }}
                return real_open64(pathname, flags, mode);
            }}
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }}
    }}
    if (!real_open64) {{ real_open64 = dlsym(RTLD_NEXT, "open64"); }}
    return real_open64(pathname, flags, mode);
}}

static int (*real_openat)(int, const char*, int, ...) = NULL;
int openat(int dirfd, const char *pathname, int flags, ...) {{
    mode_t mode = 0;
    if (flags & O_CREAT) {{
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }}
    
    if (is_gpu_path(pathname) || should_bypass_path(pathname)) {{
        if (!real_openat) {{ real_openat = dlsym(RTLD_NEXT, "openat"); }}
        return real_openat(dirfd, pathname, flags, mode);
    }}
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {{
        if (strcmp(pathname, mappings[i].real_path) == 0) {{
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) {{ 
                if (!real_openat) {{ real_openat = dlsym(RTLD_NEXT, "openat"); }}
                return real_openat(dirfd, pathname, flags, mode);
            }}
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }}
    }}
    if (!real_openat) {{ real_openat = dlsym(RTLD_NEXT, "openat"); }}
    return real_openat(dirfd, pathname, flags, mode);
}}

// =========================================================================
// SYSTEM INFORMATION INTERCEPTION
// =========================================================================

int uname(struct utsname *buf) {{
    static int (*real_uname)(struct utsname*) = NULL;
    if (!real_uname) {{ real_uname = dlsym(RTLD_NEXT, "uname"); }}
    int ret = real_uname(buf);

    strcpy(buf->nodename, FAKE_HOSTNAME);
    strcpy(buf->sysname, "Linux");
    strcpy(buf->release, "{kernel_release}");
    strcpy(buf->version, "{kernel_version}");
    strcpy(buf->machine, "x86_64");

    return ret;
}}

static int (*real_gethostname)(char*, size_t) = NULL;
int gethostname(char *name, size_t len) {{
    if (len > 0) {{
        strncpy(name, FAKE_HOSTNAME, len - 1);
        name[len - 1] = '\\0';
        return 0;
    }}
    return -1;
}}

static int (*real_sethostname)(const char*, size_t) = NULL;
int sethostname(const char *name, size_t len) {{
    return 0;
}}

static int (*real_sysinfo)(struct sysinfo*) = NULL;
int sysinfo(struct sysinfo *info) {{
    if (!real_sysinfo) {{ real_sysinfo = dlsym(RTLD_NEXT, "sysinfo"); }}
    int ret = real_sysinfo(info);
    
    if (ret == 0 && time_offset != 0) {{
        info->uptime += time_offset;
    }}
    
    return ret;
}}

// =========================================================================
// NETWORK IDENTITY INTERCEPTION
// =========================================================================

static int (*real_ioctl)(int, unsigned long, ...) = NULL;
int ioctl(int fd, unsigned long request, ...) {{
    va_list args;
    va_start(args, request);
    void *argp = va_arg(args, void*);
    va_end(args);
    
    if (!real_ioctl) {{ real_ioctl = dlsym(RTLD_NEXT, "ioctl"); }}
    int ret = real_ioctl(fd, request, argp);
    
    if (request == SIOCGIFHWADDR && ret == 0) {{
        struct ifreq *ifr = (struct ifreq*)argp;
        for (int i = 0; i < sizeof(net_spoofs) / sizeof(struct net_spoof); i++) {{
            if (strcmp(ifr->ifr_name, net_spoofs[i].interface_name) == 0) {{
                unsigned int mac[6];
                if (sscanf(net_spoofs[i].fake_mac, "%02x:%02x:%02x:%02x:%02x:%02x",
                          &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]) == 6) {{
                    for (int j = 0; j < 6; j++) {{
                        ifr->ifr_hwaddr.sa_data[j] = (unsigned char)mac[j];
                    }}
                }}
                break;
            }}
        }}
    }}
    
    return ret;
}}

// =========================================================================
// TIME MANIPULATION - FIXED TYPE SIGNATURE
// =========================================================================

static time_t (*real_time)(time_t*) = NULL;
time_t time(time_t *tloc) {{
    if (!real_time) {{ real_time = dlsym(RTLD_NEXT, "time"); }}
    time_t result = real_time(NULL);
    
    result += time_offset;
    
    if (tloc) *tloc = result;
    return result;
}}

// FIXED: Use correct signature with restrict and void*
static int (*real_gettimeofday)(struct timeval* __restrict, void* __restrict) = NULL;
int gettimeofday(struct timeval *__restrict tv, void *__restrict tz) {{
    if (!real_gettimeofday) {{ real_gettimeofday = dlsym(RTLD_NEXT, "gettimeofday"); }}
    int ret = real_gettimeofday(tv, tz);
    
    if (ret == 0 && tv && time_offset != 0) {{
        tv->tv_sec += time_offset;
    }}
    
    if (ret == 0 && tv && timing_variance > 0) {{
        tv->tv_usec += (rand() % (timing_variance * 1000));
        if (tv->tv_usec >= 1000000) {{
            tv->tv_sec += 1;
            tv->tv_usec -= 1000000;
        }}
    }}
    
    return ret;
}}

static int (*real_clock_gettime)(clockid_t, struct timespec*) = NULL;
int clock_gettime(clockid_t clk_id, struct timespec *tp) {{
    if (!real_clock_gettime) {{ real_clock_gettime = dlsym(RTLD_NEXT, "clock_gettime"); }}
    int ret = real_clock_gettime(clk_id, tp);
    
    if (ret == 0 && tp && time_offset != 0) {{
        tp->tv_sec += time_offset;
    }}
    
    if (ret == 0 && tp && timing_variance > 0) {{
        tp->tv_nsec += (rand() % (timing_variance * 1000000));
        if (tp->tv_nsec >= 1000000000) {{
            tp->tv_sec += 1;
            tp->tv_nsec -= 1000000000;
        }}
    }}
    
    return ret;
}}

// =========================================================================
// ENVIRONMENT VARIABLE MANIPULATION
// =========================================================================

static char* (*real_getenv)(const char*) = NULL;
char* getenv(const char *name) {{
    if (!real_getenv) {{ real_getenv = dlsym(RTLD_NEXT, "getenv"); }}
    
    if (strcmp(name, "HOSTNAME") == 0) {{
        return (char*)FAKE_HOSTNAME;
    }}

    // In safe_mode, avoid spoofing other environment variables
    if (safe_mode) {{
        return real_getenv(name);
    }}
    
    // Locale and language spoofing
    if (strcmp(name, "LANG") == 0) {{
        if (gpu_spoofing_disabled) {{
            return real_getenv(name);
        }}
        return "{locale}";
    }}
    if (strcmp(name, "LANGUAGE") == 0) {{
        if (gpu_spoofing_disabled) {{
            return real_getenv(name);
        }}
        return "{language}";
    }}
    if (strcmp(name, "LC_ALL") == 0) {{
        if (gpu_spoofing_disabled) {{
            return real_getenv(name);
        }}
        return "{locale}";
    }}
    if (strcmp(name, "LC_CTYPE") == 0) {{
        if (gpu_spoofing_disabled) {{
            return real_getenv(name);
        }}
        return "{locale}";
    }}
    
    // Timezone spoofing
    if (strcmp(name, "TZ") == 0) {{
        if (gpu_spoofing_disabled) {{
            return real_getenv(name);
        }}
        return "{timezone}";
    }}
    
    // Display spoofing (safe: only override when no real DISPLAY is set)
    if (strcmp(name, "DISPLAY") == 0) {{
        if (gpu_spoofing_disabled) {{
            return real_getenv(name);
        }}
        char *real = real_getenv(name);
        if (real && real[0] != '\\0') {{
            return real;
        }}
        return "{display}";
    }}
    
    return real_getenv(name);
}}

// =========================================================================
// INITIALIZATION
// =========================================================================

__attribute__((constructor))
void init_interceptor(void) {{
    srand(time(NULL));
    
    // Load real_getenv first to avoid recursion
    if (!real_getenv) {{ real_getenv = dlsym(RTLD_NEXT, "getenv"); }}
    
    char *env_offset = real_getenv("SPOOF_TIME_OFFSET");
    if (env_offset) {{
        time_offset = atol(env_offset);
    }}
    
    char *env_variance = real_getenv("SPOOF_TIMING_VARIANCE");
    if (env_variance) {{
        timing_variance = atoi(env_variance);
    }}
    
    // Check if we should disable GPU spoofing for GPU-accelerated apps
    // Read /proc/self/cmdline to detect the application
    FILE *cmdline_file = fopen("/proc/self/cmdline", "r");
    if (cmdline_file) {{
        char cmdline[4096] = {{0}};
        fread(cmdline, 1, sizeof(cmdline) - 1, cmdline_file);
        fclose(cmdline_file);
        
        // Whitelist of GPU-accelerated applications that need real GPU access
        const char* gpu_apps[] = {{
            "warp", "warp-terminal", "chrome", "chromium", "firefox",
            "electron", "code", "discord", "slack", "steam",
            "blender", "obs", "vlc", "mpv", NULL
        }};
        
        for (int i = 0; gpu_apps[i] != NULL; i++) {{
            if (strstr(cmdline, gpu_apps[i]) != NULL) {{
                gpu_spoofing_disabled = 1;
                safe_mode = 1;
                printf("[IDENTITY INTERCEPTOR] GPU spoofing disabled for: %s (safe mode enabled)\\n", gpu_apps[i]);
                break;
            }}
        }}
    }}
    
    printf("[IDENTITY INTERCEPTOR] Loaded - Profile: {profile}\\n");
    printf("[IDENTITY INTERCEPTOR] Full system identity spoofing active\\n");
}}
"""

def generate_cpuinfo(config):
    """Generate realistic /proc/cpuinfo data"""
    cpu = config["cpu"]
    cores = cpu["cores"]
    threads = cpu["threads"]
    
    lines = []
    for i in range(threads):
        core_id = i % cores
        lines.append(f'        "processor\\t: {i}\\nvendor_id\\t: {cpu["vendor_id"]}\\nmodel name\\t: {cpu["model"]}\\n"')
        lines.append(f'        "cpu MHz\\t\\t: {cpu["mhz"]}\\ncache size\\t: {cpu["cache_size"]}\\nphysical id\\t: 0\\nsiblings\\t: {threads}\\ncore id\\t\\t: {core_id}\\n"')
        lines.append(f'        "cpu cores\\t: {cores}\\nflags\\t\\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\\n\\n"')
    
    return "\n".join(lines)

def generate_network_mappings(config):
    """Generate network interface file mappings"""
    interfaces = config["network"]["interfaces"]
    suffix = config["_id_suffix"]
    
    lines = []
    for iface, mac_prefix in interfaces.items():
        lines.append(f'    {{ "/sys/class/net/{iface}/address",      "{mac_prefix}:{suffix}\\n" }},')
    
    return "\n".join(lines)

def generate_network_spoofs(config):
    """Generate network interface spoofing structs"""
    interfaces = config["network"]["interfaces"]
    suffix = config["_id_suffix"]
    
    lines = []
    for iface, mac_prefix in interfaces.items():
        lines.append(f'    {{ "{iface}",      "{mac_prefix}:{suffix}" }},')
    lines.append('    { "lo",        "00:00:00:00:00:00" },')
    
    return "\n".join(lines)

def generate_battery_mappings(config):
    """Generate battery file mappings (only for laptops)"""
    battery = config.get("battery", {})
    
    if not battery.get("has_battery", False):
        return "    // No battery (desktop system)"
    
    manufacturer = battery.get("manufacturer", "Unknown")
    model = battery.get("model", "Unknown")
    technology = battery.get("technology", "Unknown")
    capacity_wh = battery.get("capacity_wh", 50)
    voltage_v = battery.get("voltage_v", 11.4)
    
    # Calculate capacity in ¬µAh from Wh and voltage
    capacity_uah = int((capacity_wh / voltage_v) * 1000000)
    
    lines = [
        "    // Battery Information (Laptop)",
        f'    {{ "/sys/class/power_supply/BAT0/manufacturer",    "{manufacturer}\\n" }},',
        f'    {{ "/sys/class/power_supply/BAT0/model_name",       "{model}\\n" }},',
        f'    {{ "/sys/class/power_supply/BAT0/technology",       "{technology}\\n" }},',
        f'    {{ "/sys/class/power_supply/BAT0/type",             "Battery\\n" }},',
        f'    {{ "/sys/class/power_supply/BAT0/capacity",         "85\\n" }},',  # Fake charge level
        f'    {{ "/sys/class/power_supply/BAT0/status",           "Discharging\\n" }},',
        f'    {{ "/sys/class/power_supply/BAT0/voltage_now",      "{int(voltage_v * 1000000)}\\n" }},',
        f'    {{ "/sys/class/power_supply/BAT0/charge_full",      "{capacity_uah}\\n" }},',
        f'    {{ "/sys/class/power_supply/AC/online",             "0\\n" }},',
        f'    {{ "/sys/class/power_supply/AC/type",               "Mains\\n" }},',
    ]
    
    return "\n".join(lines)

def generate_memory_mappings(config):
    """Generate memory/RAM file mappings"""
    memory = config.get("memory", {})
    
    size_gb = memory.get("size_gb", 16)
    size_kb = memory.get("size_kb", 16384000)
    mem_total = size_kb  # MemTotal in kB
    mem_free = int(size_kb * 0.4)  # 40% free
    mem_available = int(size_kb * 0.6)  # 60% available
    swap_total = int(size_kb * 0.5)  # Swap = 50% of RAM
    swap_free = int(swap_total * 0.9)  # 90% swap free
    
    # Generate /proc/meminfo content - properly escaped
    meminfo_lines = [
        f"MemTotal:       {mem_total} kB",
        f"MemFree:        {mem_free} kB",
        f"MemAvailable:   {mem_available} kB",
        f"Buffers:        {int(size_kb * 0.05)} kB",
        f"Cached:         {int(size_kb * 0.15)} kB",
        "SwapCached:     0 kB",
        f"Active:         {int(size_kb * 0.25)} kB",
        f"Inactive:       {int(size_kb * 0.10)} kB",
        f"SwapTotal:      {swap_total} kB",
        f"SwapFree:       {swap_free} kB",
        "Dirty:          128 kB",
        "Writeback:      0 kB",
        f"AnonPages:      {int(size_kb * 0.20)} kB",
        f"Mapped:         {int(size_kb * 0.05)} kB",
        f"Shmem:          {int(size_kb * 0.02)} kB",
        f"Slab:           {int(size_kb * 0.03)} kB",
        "VmallocTotal:   34359738367 kB",
        f"VmallocUsed:    {int(size_kb * 0.01)} kB",
        "VmallocChunk:   0 kB",
        "HardwareCorrupted: 0 kB",
    ]
    
    # Join with \n and properly escape for C string
    meminfo_data = "\\n".join(meminfo_lines) + "\\n"
    
    return f'    {{ "/proc/meminfo", "{meminfo_data}" }},'

def generate_display_mappings(config):
    """Generate display/monitor file mappings"""
    display = config.get("display", {})
    
    name = display.get("name", "eDP-1")
    resolution = display.get("resolution", "1920x1080")
    width = display.get("width", 1920)
    height = display.get("height", 1080)
    refresh_rate = display.get("refresh_rate", 60)
    manufacturer = display.get("manufacturer", "Unknown")
    model = display.get("model", "Unknown")
    
    # Determine DRM card path based on display type
    if name.startswith("eDP"):
        drm_path = "card0-eDP-1"
    elif name.startswith("HDMI"):
        drm_path = "card0-HDMI-A-1"
    elif name.startswith("DP"):
        drm_path = "card0-DP-1"
    else:
        drm_path = "card0-eDP-1"
    
    lines = [
        f'    {{ "/sys/class/drm/{drm_path}/status",              "connected\\n" }},',
        f'    {{ "/sys/class/drm/{drm_path}/enabled",             "enabled\\n" }},',
        f'    {{ "/sys/class/drm/{drm_path}/modes",               "{resolution}\\n" }},',
        f'    {{ "/sys/class/drm/{drm_path}/dpms",                "On\\n" }},',
        f'    {{ "/sys/class/backlight/intel_backlight/max_brightness", "4882\\n" }},',
        f'    {{ "/sys/class/backlight/intel_backlight/brightness",     "3500\\n" }},',
    ]
    
    return "\n".join(lines)

def load_config():
    """Load configuration from JSON file"""
    try:
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"‚ùå Error: {CONFIG_FILE} not found!")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"‚ùå Error: Invalid JSON in {CONFIG_FILE}: {e}")
        sys.exit(1)

def generate_c_code(config):
    """Generate C code from configuration"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Flatten config for easy substitution
    values = {
        "timestamp": timestamp,
        "config_file": CONFIG_FILE,
        "profile": config["identity_profile"],
        "hostname": config["hostname"],
        "suffix": config["_id_suffix"],
        
        # Hardware
        "machine_id": config["hardware"]["machine_id"],
        "product_uuid": config["hardware"]["product_uuid"],
        "product_serial": config["hardware"]["product_serial"],
        "board_serial": config["hardware"]["board_serial"],
        "chassis_serial": config["hardware"]["chassis_serial"],
        "product_name": config["hardware"]["product_name"],
        "board_name": config["hardware"]["board_name"],
        "board_vendor": config["hardware"]["board_vendor"],
        "bios_vendor": config["hardware"]["bios_vendor"],
        "bios_version": config["hardware"]["bios_version"],
        "bios_date": config["hardware"]["bios_date"],
        
        # CPU
        "cpuinfo_data": generate_cpuinfo(config),
        
        # OS
        "os_name": config["os"]["name"],
        "os_version": config["os"]["version"],
        "os_version_id": config["os"]["version"].split()[0],  # Extract "22.04"
        "os_id": config["os"]["name"].lower(),
        "kernel_release": config["os"]["kernel_release"],
        "kernel_version": config["os"]["kernel_version"],
        
        # Storage
        "sda_serial": config["storage"]["sda_serial"],
        "nvme_serial": config["storage"]["nvme_serial"],
        "sda_model": config["storage"]["sda_model"],
        "nvme_model": config["storage"]["nvme_model"],
        
        # GPU
        "nvidia_vendor": config["gpu"]["nvidia_vendor"],
        "nvidia_device": config["gpu"]["nvidia_device"],
        "intel_vendor": config["gpu"]["intel_vendor"],
        "intel_device": config["gpu"]["intel_device"],
        
        # Network
        "network_mappings": generate_network_mappings(config),
        "network_spoofs": generate_network_spoofs(config),
        
        # Boot
        "boot_id": config["boot"]["boot_id"],
        "random_uuid": config["boot"]["random_uuid"],
        
        # Environment
        "locale": config["environment"]["locale"],
        "language": config["environment"]["language"],
        "timezone": config["environment"]["timezone"],
        "display": config["environment"]["display"],
        
        # Battery
        "battery_mappings": generate_battery_mappings(config),
        
        # Memory
        "memory_mappings": generate_memory_mappings(config),
        
        # Display
        "display_mappings": generate_display_mappings(config),
    }
    
    return C_TEMPLATE.format(**values)

def compile_library():
    """Compile the generated C code"""
    print("\nüî® Compiling identity.so...")
    
    cmd = ["gcc", "-shared", "-fPIC", "-o", OUTPUT_SO_FILE, OUTPUT_C_FILE, "-ldl"]
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print("‚úÖ Compilation successful!")
        return True
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Compilation failed!")
        print(f"STDERR: {e.stderr}")
        return False

def main():
    print("=" * 60)
    print("üõ†Ô∏è  DYNAMIC IDENTITY LIBRARY BUILDER")
    print("=" * 60)
    
    # Load configuration
    print(f"\nüìñ Loading configuration from {CONFIG_FILE}...")
    config = load_config()
    print(f"‚úÖ Loaded profile: {config['identity_profile']}")
    
    # Generate C code
    print(f"\n‚öôÔ∏è  Generating {OUTPUT_C_FILE}...")
    c_code = generate_c_code(config)
    
    with open(OUTPUT_C_FILE, 'w') as f:
        f.write(c_code)
    print(f"‚úÖ Generated {len(c_code)} bytes")
    
    # Compile
    if not compile_library():
        sys.exit(1)
    
    # Summary
    print("\n" + "=" * 60)
    print("‚úÖ BUILD COMPLETE")
    print("=" * 60)
    print(f"Profile:  {config['identity_profile']}")
    print(f"Hostname: {config['hostname']}")
    print(f"Suffix:   {config['_id_suffix']}")
    print(f"\nUsage:")
    print(f"  LD_PRELOAD=./identity.so <program>")
    print(f"  LD_PRELOAD=./identity.so /opt/warpdotdev/warp-terminal/warp")
    print("=" * 60)

if __name__ == "__main__":
    main()
