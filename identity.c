// Auto-generated by build_identity.py on 2025-11-21 03:32:09
// Profile: Aspire_5800H_ab96
// DO NOT EDIT MANUALLY - Modify identity_config.json instead

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdarg.h>
#include <time.h>
#include <sys/time.h>
#include <sys/sysinfo.h>
#include <ifaddrs.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

// =========================================================================
// CONFIGURATION - AUTO-GENERATED FROM ../config/identity_config.json
// =========================================================================

struct mapping {
    const char* real_path;
    const char* fake_data;
};

struct net_spoof {
    const char* interface_name;
    const char* fake_mac;
};

static time_t time_offset = 0;
static int timing_variance = 0;
static int gpu_spoofing_disabled = 0;

// Generated identity data
static const char* FAKE_HOSTNAME = "aspire-7-fa35";

static struct mapping mappings[] = {
    // Core System Identifiers
    { "/etc/machine-id",                  "464b5d13866aa8589c887e0b6fe18599e1\n" },
    { "/var/lib/dbus/machine-id",         "464b5d13866aa8589c887e0b6fe18599e1\n" },
    { "/sys/class/dmi/id/product_uuid",   "1bcf43cd-d9d3-38f1-7cd4-0861f4b6ca97e1\n" },
    { "/sys/class/dmi/id/product_serial", "SN-ASPIDA2543e1\n" },
    { "/sys/class/dmi/id/board_serial",   "MB-477738e1\n" },
    { "/sys/class/dmi/id/chassis_serial", "CH-0EE0B4e1\n" },
    { "/sys/class/dmi/id/product_name",   "Aspire A515-45\n" },
    { "/sys/class/dmi/id/board_name",     "Charmeleon_CFS\n" },
    { "/sys/class/dmi/id/board_vendor",   "Acer\n" },
    { "/sys/class/dmi/id/bios_vendor",    "Insyde\n" },
    { "/sys/class/dmi/id/bios_version",   "V1.14\n" },
    { "/sys/class/dmi/id/bios_date",      "08/30/2021\n" },
    
    // CPU Information
    { "/proc/cpuinfo",
        "processor\t: 0\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 0\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 1\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 1\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 2\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 2\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 3\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 3\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 4\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 4\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 5\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 5\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 6\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 6\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 7\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 7\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 8\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 0\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 9\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 1\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 10\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 2\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 11\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 3\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 12\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 4\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 13\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 5\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 14\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 6\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 15\nvendor_id\t: AuthenticAMD\nmodel name\t: AMD Ryzen 7 5800H with Radeon Graphics\n"
        "cpu MHz\t\t: 3200.000\ncache size\t: 16384 KB\nphysical id\t: 0\nsiblings\t: 16\ncore id\t\t: 7\n"
        "cpu cores\t: 8\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
    },
    
    // Operating System
    { "/etc/os-release", 
        "PRETTY_NAME=\"Manjaro Linux 23.1.0\"\nNAME=\"Manjaro Linux\"\nVERSION_ID=\"23.1.0\"\n"
        "VERSION=\"23.1.0\"\nID=manjaro linux\nID_LIKE=debian\n" 
    },
    { "/proc/version", 
        "Linux version 6.5.9-1-MANJARO (buildd@lcy02-amd64-053) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #1 SMP PREEMPT_DYNAMIC Tue Nov 7 10:00:00 UTC 2023\n" 
    },
    
    // Storage Identifiers
    { "/sys/block/sda/device/serial",     "AJ85N6579EBDD2e1\n" },
    { "/sys/block/nvme0n1/device/serial", "AJ85N657050F0Ae1\n" },
    { "/sys/block/sda/device/model",      "SK hynix Gold P31 1TB\n" },
    { "/sys/block/nvme0n1/device/model",  "SK hynix Gold P31 1TB\n" },
    
    // GPU Identifiers
    { "/sys/class/drm/card0/device/vendor",           "0x10de\n" },
    { "/sys/class/drm/card0/device/device",           "0x2482\n" },
    { "/sys/class/drm/card0/device/subsystem_vendor", "0x1028\n" },
    { "/sys/class/drm/card0/device/subsystem_device", "0x087d\n" },
    { "/sys/devices/pci0000:00/0000:00:02.0/vendor",           "0x8086\n" },
    { "/sys/devices/pci0000:00/0000:00:02.0/device",           "0x3e9b\n" },
    { "/sys/devices/pci0000:00/0000:00:02.0/subsystem_vendor", "0x1028\n" },
    { "/sys/devices/pci0000:00/0000:00:02.0/subsystem_device", "0x087d\n" },
    
    // Network MAC Addresses
    { "/sys/class/net/eth0/address",      "28:7f:cf:e1\n" },
    { "/sys/class/net/wlan0/address",      "28:7f:cf:e1\n" },
    
    // Boot and Kernel Identifiers
    { "/proc/sys/kernel/random/boot_id",  "9d592bde-2d37-3044-acbd-b3cfa080d7f7e1\n" },
    { "/proc/sys/kernel/random/uuid",     "2bb10176-0855-5cb1-50b8-b199521d4fe6e1\n" },
    
    // Container Detection Evasion
    { "/proc/self/cgroup",                "0::/\n" },
    { "/sys/hypervisor/type",             "" },
    
    // Battery Information (Laptop)
    { "/sys/class/power_supply/BAT0/manufacturer",    "Celxpert\n" },
    { "/sys/class/power_supply/BAT0/model_name",       "L19C3PD6\n" },
    { "/sys/class/power_supply/BAT0/technology",       "Li-poly\n" },
    { "/sys/class/power_supply/BAT0/type",             "Battery\n" },
    { "/sys/class/power_supply/BAT0/capacity",         "85\n" },
    { "/sys/class/power_supply/BAT0/status",           "Discharging\n" },
    { "/sys/class/power_supply/BAT0/voltage_now",      "11520000\n" },
    { "/sys/class/power_supply/BAT0/charge_full",      "4557291\n" },
    { "/sys/class/power_supply/AC/online",             "0\n" },
    { "/sys/class/power_supply/AC/type",               "Mains\n" },
    
    // Memory Information
    { "/proc/meminfo", "MemTotal:       8192000 kB\nMemFree:        3276800 kB\nMemAvailable:   4915200 kB\nBuffers:        409600 kB\nCached:         1228800 kB\nSwapCached:     0 kB\nActive:         2048000 kB\nInactive:       819200 kB\nSwapTotal:      4096000 kB\nSwapFree:       3686400 kB\nDirty:          128 kB\nWriteback:      0 kB\nAnonPages:      1638400 kB\nMapped:         409600 kB\nShmem:          163840 kB\nSlab:           245760 kB\nVmallocTotal:   34359738367 kB\nVmallocUsed:    81920 kB\nVmallocChunk:   0 kB\nHardwareCorrupted: 0 kB\n" },
    
    // Display/Monitor Information  
    { "/sys/class/drm/card0-eDP-1/status",              "connected\n" },
    { "/sys/class/drm/card0-eDP-1/enabled",             "enabled\n" },
    { "/sys/class/drm/card0-eDP-1/modes",               "2880x1800\n" },
    { "/sys/class/drm/card0-eDP-1/dpms",                "On\n" },
    { "/sys/class/backlight/intel_backlight/max_brightness", "4882\n" },
    { "/sys/class/backlight/intel_backlight/brightness",     "3500\n" },
};

static struct net_spoof net_spoofs[] = {
    { "eth0",      "28:7f:cf:e1" },
    { "wlan0",      "28:7f:cf:e1" },
    { "lo",        "00:00:00:00:00:00" },
};

// =========================================================================
// FILE OPERATION INTERCEPTION
// =========================================================================

// Helper function to check if path is GPU-related and should be skipped
static int is_gpu_path(const char* path) {
    if (gpu_spoofing_disabled) {
        // Skip GPU paths for whitelisted apps
        if (strncmp(path, "/sys/class/drm/", 15) == 0 ||
            strncmp(path, "/sys/devices/pci", 16) == 0 ||
            strncmp(path, "/dev/dri/", 9) == 0) {
            return 1;
        }
    }
    return 0;
}

static FILE* (*real_fopen)(const char*, const char*) = NULL;
FILE* fopen(const char* path, const char* mode) {
    if (is_gpu_path(path)) {
        if (!real_fopen) { real_fopen = dlsym(RTLD_NEXT, "fopen"); }
        return real_fopen(path, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(path, mappings[i].real_path) == 0) {
            return fmemopen((void*)mappings[i].fake_data, strlen(mappings[i].fake_data), mode);
        }
    }
    if (!real_fopen) { real_fopen = dlsym(RTLD_NEXT, "fopen"); }
    return real_fopen(path, mode);
}

static FILE* (*real_fopen64)(const char*, const char*) = NULL;
FILE* fopen64(const char* path, const char* mode) {
    if (is_gpu_path(path)) {
        if (!real_fopen64) { real_fopen64 = dlsym(RTLD_NEXT, "fopen64"); }
        return real_fopen64(path, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(path, mappings[i].real_path) == 0) {
            return fmemopen((void*)mappings[i].fake_data, strlen(mappings[i].fake_data), mode);
        }
    }
    if (!real_fopen64) { real_fopen64 = dlsym(RTLD_NEXT, "fopen64"); }
    return real_fopen64(path, mode);
}

static int (*real_open)(const char*, int, ...) = NULL;
int open(const char *pathname, int flags, ...) {
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }
    
    if (is_gpu_path(pathname)) {
        if (!real_open) { real_open = dlsym(RTLD_NEXT, "open"); }
        return real_open(pathname, flags, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(pathname, mappings[i].real_path) == 0) {
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) { 
                if (!real_open) { real_open = dlsym(RTLD_NEXT, "open"); }
                return real_open(pathname, flags, mode);
            }
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }
    }
    if (!real_open) { real_open = dlsym(RTLD_NEXT, "open"); }
    return real_open(pathname, flags, mode);
}

static int (*real_open64)(const char*, int, ...) = NULL;
int open64(const char *pathname, int flags, ...) {
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }
    
    if (is_gpu_path(pathname)) {
        if (!real_open64) { real_open64 = dlsym(RTLD_NEXT, "open64"); }
        return real_open64(pathname, flags, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(pathname, mappings[i].real_path) == 0) {
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) { 
                if (!real_open64) { real_open64 = dlsym(RTLD_NEXT, "open64"); }
                return real_open64(pathname, flags, mode);
            }
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }
    }
    if (!real_open64) { real_open64 = dlsym(RTLD_NEXT, "open64"); }
    return real_open64(pathname, flags, mode);
}

static int (*real_openat)(int, const char*, int, ...) = NULL;
int openat(int dirfd, const char *pathname, int flags, ...) {
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }
    
    if (is_gpu_path(pathname)) {
        if (!real_openat) { real_openat = dlsym(RTLD_NEXT, "openat"); }
        return real_openat(dirfd, pathname, flags, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(pathname, mappings[i].real_path) == 0) {
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) { 
                if (!real_openat) { real_openat = dlsym(RTLD_NEXT, "openat"); }
                return real_openat(dirfd, pathname, flags, mode);
            }
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }
    }
    if (!real_openat) { real_openat = dlsym(RTLD_NEXT, "openat"); }
    return real_openat(dirfd, pathname, flags, mode);
}

// =========================================================================
// SYSTEM INFORMATION INTERCEPTION
// =========================================================================

int uname(struct utsname *buf) {
    static int (*real_uname)(struct utsname*) = NULL;
    if (!real_uname) { real_uname = dlsym(RTLD_NEXT, "uname"); }
    int ret = real_uname(buf);

    strcpy(buf->nodename, FAKE_HOSTNAME);
    strcpy(buf->sysname, "Linux");
    strcpy(buf->release, "6.5.9-1-MANJARO");
    strcpy(buf->version, "#1 SMP PREEMPT_DYNAMIC Tue Nov 7 10:00:00 UTC 2023");
    strcpy(buf->machine, "x86_64");

    return ret;
}

static int (*real_gethostname)(char*, size_t) = NULL;
int gethostname(char *name, size_t len) {
    if (len > 0) {
        strncpy(name, FAKE_HOSTNAME, len - 1);
        name[len - 1] = '\0';
        return 0;
    }
    return -1;
}

static int (*real_sethostname)(const char*, size_t) = NULL;
int sethostname(const char *name, size_t len) {
    return 0;
}

static int (*real_sysinfo)(struct sysinfo*) = NULL;
int sysinfo(struct sysinfo *info) {
    if (!real_sysinfo) { real_sysinfo = dlsym(RTLD_NEXT, "sysinfo"); }
    int ret = real_sysinfo(info);
    
    if (ret == 0 && time_offset != 0) {
        info->uptime += time_offset;
    }
    
    return ret;
}

// =========================================================================
// NETWORK IDENTITY INTERCEPTION
// =========================================================================

static int (*real_ioctl)(int, unsigned long, ...) = NULL;
int ioctl(int fd, unsigned long request, ...) {
    va_list args;
    va_start(args, request);
    void *argp = va_arg(args, void*);
    va_end(args);
    
    if (!real_ioctl) { real_ioctl = dlsym(RTLD_NEXT, "ioctl"); }
    int ret = real_ioctl(fd, request, argp);
    
    if (request == SIOCGIFHWADDR && ret == 0) {
        struct ifreq *ifr = (struct ifreq*)argp;
        for (int i = 0; i < sizeof(net_spoofs) / sizeof(struct net_spoof); i++) {
            if (strcmp(ifr->ifr_name, net_spoofs[i].interface_name) == 0) {
                unsigned int mac[6];
                if (sscanf(net_spoofs[i].fake_mac, "%02x:%02x:%02x:%02x:%02x:%02x",
                          &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]) == 6) {
                    for (int j = 0; j < 6; j++) {
                        ifr->ifr_hwaddr.sa_data[j] = (unsigned char)mac[j];
                    }
                }
                break;
            }
        }
    }
    
    return ret;
}

// =========================================================================
// TIME MANIPULATION - FIXED TYPE SIGNATURE
// =========================================================================

static time_t (*real_time)(time_t*) = NULL;
time_t time(time_t *tloc) {
    if (!real_time) { real_time = dlsym(RTLD_NEXT, "time"); }
    time_t result = real_time(NULL);
    
    result += time_offset;
    
    if (tloc) *tloc = result;
    return result;
}

// FIXED: Use correct signature with restrict and void*
static int (*real_gettimeofday)(struct timeval* __restrict, void* __restrict) = NULL;
int gettimeofday(struct timeval *__restrict tv, void *__restrict tz) {
    if (!real_gettimeofday) { real_gettimeofday = dlsym(RTLD_NEXT, "gettimeofday"); }
    int ret = real_gettimeofday(tv, tz);
    
    if (ret == 0 && tv && time_offset != 0) {
        tv->tv_sec += time_offset;
    }
    
    if (ret == 0 && tv && timing_variance > 0) {
        tv->tv_usec += (rand() % (timing_variance * 1000));
        if (tv->tv_usec >= 1000000) {
            tv->tv_sec += 1;
            tv->tv_usec -= 1000000;
        }
    }
    
    return ret;
}

static int (*real_clock_gettime)(clockid_t, struct timespec*) = NULL;
int clock_gettime(clockid_t clk_id, struct timespec *tp) {
    if (!real_clock_gettime) { real_clock_gettime = dlsym(RTLD_NEXT, "clock_gettime"); }
    int ret = real_clock_gettime(clk_id, tp);
    
    if (ret == 0 && tp && time_offset != 0) {
        tp->tv_sec += time_offset;
    }
    
    if (ret == 0 && tp && timing_variance > 0) {
        tp->tv_nsec += (rand() % (timing_variance * 1000000));
        if (tp->tv_nsec >= 1000000000) {
            tp->tv_sec += 1;
            tp->tv_nsec -= 1000000000;
        }
    }
    
    return ret;
}

// =========================================================================
// ENVIRONMENT VARIABLE MANIPULATION
// =========================================================================

static char* (*real_getenv)(const char*) = NULL;
char* getenv(const char *name) {
    if (!real_getenv) { real_getenv = dlsym(RTLD_NEXT, "getenv"); }
    
    if (strcmp(name, "HOSTNAME") == 0) {
        return (char*)FAKE_HOSTNAME;
    }
    
    // Locale and language spoofing
    if (strcmp(name, "LANG") == 0) {
        if (gpu_spoofing_disabled) {
            return real_getenv(name);
        }
        return "de_DE.UTF-8";
    }
    if (strcmp(name, "LANGUAGE") == 0) {
        if (gpu_spoofing_disabled) {
            return real_getenv(name);
        }
        return "de_DE:de";
    }
    if (strcmp(name, "LC_ALL") == 0) {
        if (gpu_spoofing_disabled) {
            return real_getenv(name);
        }
        return "de_DE.UTF-8";
    }
    if (strcmp(name, "LC_CTYPE") == 0) {
        if (gpu_spoofing_disabled) {
            return real_getenv(name);
        }
        return "de_DE.UTF-8";
    }
    
    // Timezone spoofing
    if (strcmp(name, "TZ") == 0) {
        if (gpu_spoofing_disabled) {
            return real_getenv(name);
        }
        return "Europe/London";
    }
    
    // Display spoofing (safe: only override when no real DISPLAY is set)
    if (strcmp(name, "DISPLAY") == 0) {
        if (gpu_spoofing_disabled) {
            return real_getenv(name);
        }
        char *real = real_getenv(name);
        if (real && real[0] != '\0') {
            return real;
        }
        return ":0";
    }
    
    return real_getenv(name);
}

// =========================================================================
// INITIALIZATION
// =========================================================================

__attribute__((constructor))
void init_interceptor(void) {
    srand(time(NULL));
    
    // Load real_getenv first to avoid recursion
    if (!real_getenv) { real_getenv = dlsym(RTLD_NEXT, "getenv"); }
    
    char *env_offset = real_getenv("SPOOF_TIME_OFFSET");
    if (env_offset) {
        time_offset = atol(env_offset);
    }
    
    char *env_variance = real_getenv("SPOOF_TIMING_VARIANCE");
    if (env_variance) {
        timing_variance = atoi(env_variance);
    }
    
    // Check if we should disable GPU spoofing for GPU-accelerated apps
    // Read /proc/self/cmdline to detect the application
    FILE *cmdline_file = fopen("/proc/self/cmdline", "r");
    if (cmdline_file) {
        char cmdline[4096] = {0};
        fread(cmdline, 1, sizeof(cmdline) - 1, cmdline_file);
        fclose(cmdline_file);
        
        // Whitelist of GPU-accelerated applications that need real GPU access
        const char* gpu_apps[] = {
            "warp", "warp-terminal", "chrome", "chromium", "firefox",
            "electron", "code", "discord", "slack", "steam",
            "blender", "obs", "vlc", "mpv", NULL
        };
        
        for (int i = 0; gpu_apps[i] != NULL; i++) {
            if (strstr(cmdline, gpu_apps[i]) != NULL) {
                gpu_spoofing_disabled = 1;
                printf("[IDENTITY INTERCEPTOR] GPU spoofing disabled for: %s\n", gpu_apps[i]);
                break;
            }
        }
    }
    
    printf("[IDENTITY INTERCEPTOR] Loaded - Profile: Aspire_5800H_ab96\n");
    printf("[IDENTITY INTERCEPTOR] Full system identity spoofing active\n");
}
