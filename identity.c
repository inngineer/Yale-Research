// Auto-generated by build_identity.py on 2025-11-21 03:25:29
// Profile: ZenBook_CPU_b049
// DO NOT EDIT MANUALLY - Modify identity_config.json instead

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdarg.h>
#include <time.h>
#include <sys/time.h>
#include <sys/sysinfo.h>
#include <ifaddrs.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

// =========================================================================
// CONFIGURATION - AUTO-GENERATED FROM ../config/identity_config.json
// =========================================================================

struct mapping {
    const char* real_path;
    const char* fake_data;
};

struct net_spoof {
    const char* interface_name;
    const char* fake_mac;
};

static time_t time_offset = 0;
static int timing_variance = 0;
static int gpu_spoofing_disabled = 0;

// Generated identity data
static const char* FAKE_HOSTNAME = "zenbook-i7-12700h-bc91";

static struct mapping mappings[] = {
    // Core System Identifiers
    { "/etc/machine-id",                  "75cd8058713a1b08bd72408e5f6332f6ff\n" },
    { "/var/lib/dbus/machine-id",         "75cd8058713a1b08bd72408e5f6332f6ff\n" },
    { "/sys/class/dmi/id/product_uuid",   "b40d68c5-f668-287f-37af-62112023fd73ff\n" },
    { "/sys/class/dmi/id/product_serial", "SN-ZENB2213F9ff\n" },
    { "/sys/class/dmi/id/board_serial",   "MB-C8AE85ff\n" },
    { "/sys/class/dmi/id/chassis_serial", "CH-FBCCD3ff\n" },
    { "/sys/class/dmi/id/product_name",   "ZenBook UX425EA\n" },
    { "/sys/class/dmi/id/board_name",     "UX425EA\n" },
    { "/sys/class/dmi/id/board_vendor",   "ASUSTeK COMPUTER INC.\n" },
    { "/sys/class/dmi/id/bios_vendor",    "American Megatrends Inc.\n" },
    { "/sys/class/dmi/id/bios_version",   "UX425EA.304\n" },
    { "/sys/class/dmi/id/bios_date",      "03/23/2022\n" },
    
    // CPU Information
    { "/proc/cpuinfo",
        "processor\t: 0\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 0\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 1\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 1\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 2\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 2\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 3\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 3\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 4\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 4\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 5\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 5\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 6\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 6\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 7\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 7\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 8\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 8\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 9\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 9\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 10\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 10\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 11\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 11\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 12\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 12\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 13\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 13\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 14\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 0\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 15\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 1\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 16\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 2\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 17\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 3\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 18\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 4\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
        "processor\t: 19\nvendor_id\t: GenuineIntel\nmodel name\t: Intel(R) Core(TM) i7-12700H CPU @ 2.30GHz\n"
        "cpu MHz\t\t: 2300.000\ncache size\t: 24576 KB\nphysical id\t: 0\nsiblings\t: 20\ncore id\t\t: 5\n"
        "cpu cores\t: 14\nflags\t\t: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov\n\n"
    },
    
    // Operating System
    { "/etc/os-release", 
        "PRETTY_NAME=\"Ubuntu 23.10\"\nNAME=\"Ubuntu\"\nVERSION_ID=\"23.10\"\n"
        "VERSION=\"23.10\"\nID=ubuntu\nID_LIKE=debian\n" 
    },
    { "/proc/version", 
        "Linux version 6.5.0-14-generic (buildd@lcy02-amd64-053) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #14-Ubuntu SMP PREEMPT_DYNAMIC Tue Nov 14 14:59:49 UTC 2023\n" 
    },
    
    // Storage Identifiers
    { "/sys/block/sda/device/serial",     "S6PNNG0R66566Dff\n" },
    { "/sys/block/nvme0n1/device/serial", "S6PNNG0RFE8849ff\n" },
    { "/sys/block/sda/device/model",      "Samsung SSD 870 EVO 1TB\n" },
    { "/sys/block/nvme0n1/device/model",  "Samsung SSD 870 EVO 1TB\n" },
    
    // GPU Identifiers
    { "/sys/class/drm/card0/device/vendor",           "0x10de\n" },
    { "/sys/class/drm/card0/device/device",           "0x21c4\n" },
    { "/sys/class/drm/card0/device/subsystem_vendor", "0x1028\n" },
    { "/sys/class/drm/card0/device/subsystem_device", "0x087d\n" },
    { "/sys/devices/pci0000:00/0000:00:02.0/vendor",           "0x8086\n" },
    { "/sys/devices/pci0000:00/0000:00:02.0/device",           "0x3e9b\n" },
    { "/sys/devices/pci0000:00/0000:00:02.0/subsystem_vendor", "0x1028\n" },
    { "/sys/devices/pci0000:00/0000:00:02.0/subsystem_device", "0x087d\n" },
    
    // Network MAC Addresses
    { "/sys/class/net/eth0/address",      "b8:86:87:ff\n" },
    { "/sys/class/net/wlan0/address",      "b8:86:87:ff\n" },
    
    // Boot and Kernel Identifiers
    { "/proc/sys/kernel/random/boot_id",  "00288332-ead3-4a8b-a288-6a9da9a0cb22ff\n" },
    { "/proc/sys/kernel/random/uuid",     "d03e45e1-6ed3-c441-c5f8-4b6abc97cf79ff\n" },
    
    // Container Detection Evasion
    { "/proc/self/cgroup",                "0::/\n" },
    { "/sys/hypervisor/type",             "" },
    
    // Battery Information (Laptop)
    { "/sys/class/power_supply/BAT0/manufacturer",    "LGC\n" },
    { "/sys/class/power_supply/BAT0/model_name",       "5B10W13931\n" },
    { "/sys/class/power_supply/BAT0/technology",       "Li-poly\n" },
    { "/sys/class/power_supply/BAT0/type",             "Battery\n" },
    { "/sys/class/power_supply/BAT0/capacity",         "85\n" },
    { "/sys/class/power_supply/BAT0/status",           "Discharging\n" },
    { "/sys/class/power_supply/BAT0/voltage_now",      "15360000\n" },
    { "/sys/class/power_supply/BAT0/charge_full",      "3710937\n" },
    { "/sys/class/power_supply/AC/online",             "0\n" },
    { "/sys/class/power_supply/AC/type",               "Mains\n" },
    
    // Memory Information
    { "/proc/meminfo", "MemTotal:       32768000 kB\nMemFree:        13107200 kB\nMemAvailable:   19660800 kB\nBuffers:        1638400 kB\nCached:         4915200 kB\nSwapCached:     0 kB\nActive:         8192000 kB\nInactive:       3276800 kB\nSwapTotal:      16384000 kB\nSwapFree:       14745600 kB\nDirty:          128 kB\nWriteback:      0 kB\nAnonPages:      6553600 kB\nMapped:         1638400 kB\nShmem:          655360 kB\nSlab:           983040 kB\nVmallocTotal:   34359738367 kB\nVmallocUsed:    327680 kB\nVmallocChunk:   0 kB\nHardwareCorrupted: 0 kB\n" },
    
    // Display/Monitor Information  
    { "/sys/class/drm/card0-eDP-1/status",              "connected\n" },
    { "/sys/class/drm/card0-eDP-1/enabled",             "enabled\n" },
    { "/sys/class/drm/card0-eDP-1/modes",               "2880x1800\n" },
    { "/sys/class/drm/card0-eDP-1/dpms",                "On\n" },
    { "/sys/class/backlight/intel_backlight/max_brightness", "4882\n" },
    { "/sys/class/backlight/intel_backlight/brightness",     "3500\n" },
};

static struct net_spoof net_spoofs[] = {
    { "eth0",      "b8:86:87:ff" },
    { "wlan0",      "b8:86:87:ff" },
    { "lo",        "00:00:00:00:00:00" },
};

// =========================================================================
// FILE OPERATION INTERCEPTION
// =========================================================================

// Helper function to check if path is GPU-related and should be skipped
static int is_gpu_path(const char* path) {
    if (gpu_spoofing_disabled) {
        // Skip GPU paths for whitelisted apps
        if (strncmp(path, "/sys/class/drm/", 15) == 0 ||
            strncmp(path, "/sys/devices/pci", 16) == 0 ||
            strncmp(path, "/dev/dri/", 9) == 0) {
            return 1;
        }
    }
    return 0;
}

static FILE* (*real_fopen)(const char*, const char*) = NULL;
FILE* fopen(const char* path, const char* mode) {
    if (is_gpu_path(path)) {
        if (!real_fopen) { real_fopen = dlsym(RTLD_NEXT, "fopen"); }
        return real_fopen(path, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(path, mappings[i].real_path) == 0) {
            return fmemopen((void*)mappings[i].fake_data, strlen(mappings[i].fake_data), mode);
        }
    }
    if (!real_fopen) { real_fopen = dlsym(RTLD_NEXT, "fopen"); }
    return real_fopen(path, mode);
}

static FILE* (*real_fopen64)(const char*, const char*) = NULL;
FILE* fopen64(const char* path, const char* mode) {
    if (is_gpu_path(path)) {
        if (!real_fopen64) { real_fopen64 = dlsym(RTLD_NEXT, "fopen64"); }
        return real_fopen64(path, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(path, mappings[i].real_path) == 0) {
            return fmemopen((void*)mappings[i].fake_data, strlen(mappings[i].fake_data), mode);
        }
    }
    if (!real_fopen64) { real_fopen64 = dlsym(RTLD_NEXT, "fopen64"); }
    return real_fopen64(path, mode);
}

static int (*real_open)(const char*, int, ...) = NULL;
int open(const char *pathname, int flags, ...) {
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }
    
    if (is_gpu_path(pathname)) {
        if (!real_open) { real_open = dlsym(RTLD_NEXT, "open"); }
        return real_open(pathname, flags, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(pathname, mappings[i].real_path) == 0) {
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) { 
                if (!real_open) { real_open = dlsym(RTLD_NEXT, "open"); }
                return real_open(pathname, flags, mode);
            }
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }
    }
    if (!real_open) { real_open = dlsym(RTLD_NEXT, "open"); }
    return real_open(pathname, flags, mode);
}

static int (*real_open64)(const char*, int, ...) = NULL;
int open64(const char *pathname, int flags, ...) {
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }
    
    if (is_gpu_path(pathname)) {
        if (!real_open64) { real_open64 = dlsym(RTLD_NEXT, "open64"); }
        return real_open64(pathname, flags, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(pathname, mappings[i].real_path) == 0) {
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) { 
                if (!real_open64) { real_open64 = dlsym(RTLD_NEXT, "open64"); }
                return real_open64(pathname, flags, mode);
            }
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }
    }
    if (!real_open64) { real_open64 = dlsym(RTLD_NEXT, "open64"); }
    return real_open64(pathname, flags, mode);
}

static int (*real_openat)(int, const char*, int, ...) = NULL;
int openat(int dirfd, const char *pathname, int flags, ...) {
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }
    
    if (is_gpu_path(pathname)) {
        if (!real_openat) { real_openat = dlsym(RTLD_NEXT, "openat"); }
        return real_openat(dirfd, pathname, flags, mode);
    }
    
    for (int i = 0; i < (sizeof(mappings) / sizeof(struct mapping)); i++) {
        if (strcmp(pathname, mappings[i].real_path) == 0) {
            char template[] = "/tmp/fakefile-XXXXXX";
            int fd = mkstemp(template);
            if (fd == -1) { 
                if (!real_openat) { real_openat = dlsym(RTLD_NEXT, "openat"); }
                return real_openat(dirfd, pathname, flags, mode);
            }
            unlink(template);
            write(fd, mappings[i].fake_data, strlen(mappings[i].fake_data));
            lseek(fd, 0, SEEK_SET);
            return fd;
        }
    }
    if (!real_openat) { real_openat = dlsym(RTLD_NEXT, "openat"); }
    return real_openat(dirfd, pathname, flags, mode);
}

// =========================================================================
// SYSTEM INFORMATION INTERCEPTION
// =========================================================================

int uname(struct utsname *buf) {
    static int (*real_uname)(struct utsname*) = NULL;
    if (!real_uname) { real_uname = dlsym(RTLD_NEXT, "uname"); }
    int ret = real_uname(buf);

    strcpy(buf->nodename, FAKE_HOSTNAME);
    strcpy(buf->sysname, "Linux");
    strcpy(buf->release, "6.5.0-14-generic");
    strcpy(buf->version, "#14-Ubuntu SMP PREEMPT_DYNAMIC Tue Nov 14 14:59:49 UTC 2023");
    strcpy(buf->machine, "x86_64");

    return ret;
}

static int (*real_gethostname)(char*, size_t) = NULL;
int gethostname(char *name, size_t len) {
    if (len > 0) {
        strncpy(name, FAKE_HOSTNAME, len - 1);
        name[len - 1] = '\0';
        return 0;
    }
    return -1;
}

static int (*real_sethostname)(const char*, size_t) = NULL;
int sethostname(const char *name, size_t len) {
    return 0;
}

static int (*real_sysinfo)(struct sysinfo*) = NULL;
int sysinfo(struct sysinfo *info) {
    if (!real_sysinfo) { real_sysinfo = dlsym(RTLD_NEXT, "sysinfo"); }
    int ret = real_sysinfo(info);
    
    if (ret == 0 && time_offset != 0) {
        info->uptime += time_offset;
    }
    
    return ret;
}

// =========================================================================
// NETWORK IDENTITY INTERCEPTION
// =========================================================================

static int (*real_ioctl)(int, unsigned long, ...) = NULL;
int ioctl(int fd, unsigned long request, ...) {
    va_list args;
    va_start(args, request);
    void *argp = va_arg(args, void*);
    va_end(args);
    
    if (!real_ioctl) { real_ioctl = dlsym(RTLD_NEXT, "ioctl"); }
    int ret = real_ioctl(fd, request, argp);
    
    if (request == SIOCGIFHWADDR && ret == 0) {
        struct ifreq *ifr = (struct ifreq*)argp;
        for (int i = 0; i < sizeof(net_spoofs) / sizeof(struct net_spoof); i++) {
            if (strcmp(ifr->ifr_name, net_spoofs[i].interface_name) == 0) {
                unsigned int mac[6];
                if (sscanf(net_spoofs[i].fake_mac, "%02x:%02x:%02x:%02x:%02x:%02x",
                          &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]) == 6) {
                    for (int j = 0; j < 6; j++) {
                        ifr->ifr_hwaddr.sa_data[j] = (unsigned char)mac[j];
                    }
                }
                break;
            }
        }
    }
    
    return ret;
}

// =========================================================================
// TIME MANIPULATION - FIXED TYPE SIGNATURE
// =========================================================================

static time_t (*real_time)(time_t*) = NULL;
time_t time(time_t *tloc) {
    if (!real_time) { real_time = dlsym(RTLD_NEXT, "time"); }
    time_t result = real_time(NULL);
    
    result += time_offset;
    
    if (tloc) *tloc = result;
    return result;
}

// FIXED: Use correct signature with restrict and void*
static int (*real_gettimeofday)(struct timeval* __restrict, void* __restrict) = NULL;
int gettimeofday(struct timeval *__restrict tv, void *__restrict tz) {
    if (!real_gettimeofday) { real_gettimeofday = dlsym(RTLD_NEXT, "gettimeofday"); }
    int ret = real_gettimeofday(tv, tz);
    
    if (ret == 0 && tv && time_offset != 0) {
        tv->tv_sec += time_offset;
    }
    
    if (ret == 0 && tv && timing_variance > 0) {
        tv->tv_usec += (rand() % (timing_variance * 1000));
        if (tv->tv_usec >= 1000000) {
            tv->tv_sec += 1;
            tv->tv_usec -= 1000000;
        }
    }
    
    return ret;
}

static int (*real_clock_gettime)(clockid_t, struct timespec*) = NULL;
int clock_gettime(clockid_t clk_id, struct timespec *tp) {
    if (!real_clock_gettime) { real_clock_gettime = dlsym(RTLD_NEXT, "clock_gettime"); }
    int ret = real_clock_gettime(clk_id, tp);
    
    if (ret == 0 && tp && time_offset != 0) {
        tp->tv_sec += time_offset;
    }
    
    if (ret == 0 && tp && timing_variance > 0) {
        tp->tv_nsec += (rand() % (timing_variance * 1000000));
        if (tp->tv_nsec >= 1000000000) {
            tp->tv_sec += 1;
            tp->tv_nsec -= 1000000000;
        }
    }
    
    return ret;
}

// =========================================================================
// ENVIRONMENT VARIABLE MANIPULATION
// =========================================================================

static char* (*real_getenv)(const char*) = NULL;
char* getenv(const char *name) {
    if (!real_getenv) { real_getenv = dlsym(RTLD_NEXT, "getenv"); }
    
    if (strcmp(name, "HOSTNAME") == 0) {
        return (char*)FAKE_HOSTNAME;
    }
    
    // Locale and language spoofing
    if (strcmp(name, "LANG") == 0) {
        return "en_GB.UTF-8";
    }
    if (strcmp(name, "LANGUAGE") == 0) {
        return "en_GB:en";
    }
    if (strcmp(name, "LC_ALL") == 0) {
        return "en_GB.UTF-8";
    }
    if (strcmp(name, "LC_CTYPE") == 0) {
        return "en_GB.UTF-8";
    }
    
    // Timezone spoofing
    if (strcmp(name, "TZ") == 0) {
        return "Asia/Shanghai";
    }
    
// Display spoofing (safe: only override when no real DISPLAY is set)
    if (strcmp(name, "DISPLAY") == 0) {
        char *real = real_getenv(name);
        if (real && real[0] != ' ') {
            return real;
        }
        return ":0";
    }
    
    return real_getenv(name);
}

// =========================================================================
// INITIALIZATION
// =========================================================================

__attribute__((constructor))
void init_interceptor(void) {
    srand(time(NULL));
    
    // Load real_getenv first to avoid recursion
    if (!real_getenv) { real_getenv = dlsym(RTLD_NEXT, "getenv"); }
    
    char *env_offset = real_getenv("SPOOF_TIME_OFFSET");
    if (env_offset) {
        time_offset = atol(env_offset);
    }
    
    char *env_variance = real_getenv("SPOOF_TIMING_VARIANCE");
    if (env_variance) {
        timing_variance = atoi(env_variance);
    }
    
    // Check if we should disable GPU spoofing for GPU-accelerated apps
    // Read /proc/self/cmdline to detect the application
    FILE *cmdline_file = fopen("/proc/self/cmdline", "r");
    if (cmdline_file) {
        char cmdline[4096] = {0};
        fread(cmdline, 1, sizeof(cmdline) - 1, cmdline_file);
        fclose(cmdline_file);
        
        // Whitelist of GPU-accelerated applications that need real GPU access
        const char* gpu_apps[] = {
            "warp", "warp-terminal", "chrome", "chromium", "firefox",
            "electron", "code", "discord", "slack", "steam",
            "blender", "obs", "vlc", "mpv", NULL
        };
        
        for (int i = 0; gpu_apps[i] != NULL; i++) {
            if (strstr(cmdline, gpu_apps[i]) != NULL) {
                gpu_spoofing_disabled = 1;
                printf("[IDENTITY INTERCEPTOR] GPU spoofing disabled for: %s\n", gpu_apps[i]);
                break;
            }
        }
    }
    
    printf("[IDENTITY INTERCEPTOR] Loaded - Profile: ZenBook_CPU_b049\n");
    printf("[IDENTITY INTERCEPTOR] Full system identity spoofing active\n");
}
